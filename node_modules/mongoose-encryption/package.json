{
  "name": "mongoose-encryption",
  "description": "Simple encryption and authentication plugin for Mongoose",
  "version": "1.1.0",
  "author": {
    "name": "Joe Goldbeck"
  },
  "keywords": [
    "mongoose",
    "mongo",
    "encrypt",
    "encryption",
    "sign",
    "authenticate",
    "authentication",
    "mongodb",
    "HMAC"
  ],
  "main": "./index.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/joegoldbeck/mongoose-encryption.git"
  },
  "bugs": {
    "url": "https://github.com/joegoldbeck/mongoose-encryption/issues"
  },
  "homepage": "https://github.com/joegoldbeck/mongoose-encryption",
  "license": "MIT",
  "dependencies": {
    "dotty": "0.0.2",
    "mongoose": "3.8.x",
    "underscore": "1.5.x",
    "buffer-equal-constant-time": "1.0.1",
    "json-stable-stringify": "1.0.0",
    "async": "0.9.0"
  },
  "devDependencies": {
    "mocha": "1.x.x",
    "chai": "1.x.x",
    "coffee-script": "1.7.x",
    "sinon": "~1.10.3"
  },
  "engines": {
    "node": ">= 0.10.25"
  },
  "scripts": {
    "test": "mocha ./test --compilers coffee:coffee-script/register --timeout 3000"
  },
  "readme": "mongoose-encryption\n==================\nSimple encryption and authentication for mongoose documents. Relies on the Node `crypto` module. Encryption and decryption happen transparently during save and find. Rather than encrypting fields individually, this plugin takes advantage of the BSON nature of mongoDB documents to encrypt multiple fields at once.\n\n\n## How it Works\n\nEncryption is performed using `AES-256-CBC` with a random, unique initialization vector for each operation. Authentication is performed using `HMAC-SHA-512`.\n\nTo encrypt, the relevant fields are removed from the document, converted to JSON, enciphered in `Buffer` format with the IV and plugin version prepended, and inserted into the `_ct` field of the document. Mongoose converts the `_ct` field to `Binary` when sending to mongo.\n\nTo decrypt, the `_ct` field is deciphered, the JSON is parsed, and the individual fields are inserted back into the document as their original data types.\n\nTo sign, the relevant fields (which necessarily include `_id` and `_ct`)  are stably stringified and signed along with the list of signed fields, the collection name, and the plugin version. This signature is stored in `Buffer` format in the `_ac` field with the plugin version prepended and the list of signed fields appended. Mongoose converts the field to `Binary` when sending to mongo.\n\nTo authenticate, a signature is generated in the same fashion as above, and compared to the `_ac` field on the document. If the signatures are equal, authentication succeeds. If they are not, or if `_ac` is missing from the document, authentication fails and an error is passed to the callback.\n\nDuring `save`, documents are encrypted and then signed. During `find`, documents are authenticated and then decrypted\n\n## Installation\n\n`npm install mongoose-encryption`\n\n\n## Usage\nGenerate and store keys separately. They should probably live in environment variables, but be sure not to lose them. You can either use a single `secret` string of any length; or a pair of base64 strings (a 32-byte `encryptionKey` and a 64-byte `signingKey`).\n\nA great way to securely generate this pair of keys is `openssl rand -base64 32; openssl rand -base64 64;`\n\n### Basic\n\nBy default, all fields are encrypted except for `_id`, `__v`, and fields with indexes\n\n```\nvar mongoose = require('mongoose');\nvar encrypt = require('mongoose-encryption');\n\nvar userSchema = new mongoose.Schema({\n    name: String,\n    age: Number\n    // whatever else\n});\n\n// Add any other plugins or middleware here. For example, middleware for hashing passwords\n\nvar encKey = process.env.SOME_32BYTE_BASE64_STRING;\nvar sigKey = process.env.SOME_64BYTE_BASE64_STRING;\n\nuserSchema.plugin(encrypt, { encryptionKey: encKey, signingKey: sigKey });\n// This adds _ct and _ac fields to the schema, as well as pre 'init' and pre 'save' middleware,\n// and encrypt, decrypt, sign, and authenticate instance methods\n\nUser = mongoose.model('User', userSchema);\n```\n\nAnd you're all set. You should be able to `find` and make `New` documents as normal, but you should not use the `lean` option on a `find` if you want the document to be authenticated and decrypted. `findOne`, `findById`, etc..., as well as `save` and `create` also all work as normal. `update` will work fine on unencrypted and unauthenticated fields, but will not work correctly if encrypted or authenticated fields are involved.\n\n\n### Exclude Certain Fields from Encryption\n\nTo exclude additional fields (other than _id and indexed fields), pass the `excludeFromEncryption` option\n\n```\n// exclude age from encryption, still encrypt name. _id will also remain unencrypted\nuserSchema.plugin(encrypt, { encryptionKey: encKey, signingKey: sigKey, excludeFromEncryption: ['age'] });\n```\n\n### Encrypt Only Certain Fields\n\nYou can also specify exactly which fields to encrypt with the `encryptedFields` option. This overrides the defaults and all other options.\n\n```\n// encrypt age regardless of any other options. name and _id will be left unencrypted\nuserSchema.plugin(encrypt, { encryptionKey: encKey, signingKey: sigKey, encryptedFields: ['age'] });\n```\n\n### Authenticate Additional Fields\nBy default, the encrypted parts of documents are authenticated along with the `_id` to prevent copy/paste attacks by an attacker with database write access. If you use one of the above options such that only part of your document is encrypted, you might want to authenticate the fields kept in cleartext to prevent tampering. In particular, consider authenticating any fields used for authorization, such as `email`, `isAdmin`, or `password` (though password should probably be in the encrypted block). You can do this with the `additionalAuthenticatedFields` option.\n```\n// keep isAdmin in clear but pass error on find() if tampered with\nuserSchema.plugin(encrypt, {\n    encryptionKey: encKey,\n    signingKey: sigKey,\n    excludeFromEncryption: ['isAdmin'],\n    additionalAuthenticatedFields: ['isAdmin']\n});\n```\nNote that the most secure choice is to include all non-encrypted fields for authentication, as this prevents tampering with any part of the document.\n\n### Renaming an Encrypted Collection\n\nTo guard against cross-collection attacks, the collection name is included in the signed block. This means that if you simply change the name of a collection in Mongo (and therefore update the model name in Mongoose), authentication would fail. To restore functionality, pass in the `collectionId` option with the old model name.\n```\n// used to be the `users` collection, now it's `powerusers`\npoweruserSchema.plugin(encrypt, {\n    encryptionKey: encKey,\n    signingKey: sigKey,\n    collectionId: `User` // this corresponds to the old model name\n});\n\nPowerUser = mongoose.model('PowerUser', poweruserSchema);\n```\n\n### Encrypt Specific Fields of Sub Docs\n\nYou can even encrypt fields of sub-documents, you just need to add the `encrypt` plugin to the subdocument schema. *Subdocuments are not self-authenticated*, so you should consider adding the `encrypt` plugin to the parent schema as well for the authentication it provides, in addition to adding the `encrypt.encryptedChildren` plugin to the parent if you continue to work with documents following failed saves caused by validation errors.\n```\nvar hidingPlaceSchema = new Schema({\n  latitude: Number,\n  longitude: Number,\n  nickname: String\n});\n\nhidingPlaceSchema.plugin(encrypt, {\n  encryptionKey: encKey,\n  signingKey: sigKey,\n  excludeFromEncryption: ['nickname']\n});\n\nvar userSchema = new Schema({\n  name: String,\n  locationsOfGold: [hidingPlaceSchema]\n});\n\n// optional but recommended: authenticate subdocuments from the parent document\nuserSchema.plugin(encrypt, {\n  encryptionKey: encKey,\n  signingKey: sigKey,\n  additionalAuthenticatedFields: ['locationsOfGold'],\n  encryptedFields: []\n});\n\n// optional. only needed for correct document behavior following validation errors during a save\nuserSchema.plugin(encrypt.encryptedChildren);\n\n```\nThe need for `encrypt.encryptedChildren` arises because subdocument 'pre save' hooks are called before parent validation completes, and there are no subdocument hooks that fire when parent validation fails. Without the plugin, if you repair a parent doc after a failed save and then try to save again, data in the encrypted fields of the subdocuments will be lost.\n\n\n### Save Behavior\n\nBy default, documents are decrypted after they are saved to the database, so that you can continue to work with them transparently.\n```\njoe = new User ({ name: 'Joe', age: 42 });\njoe.save(function(err){ // encrypted when sent to the database\n                        // decrypted in the callback\n  console.log(joe.name); // Joe\n  console.log(joe.age); // 42\n  console.log(joe._ct); // undefined\n});\n\n```\nYou can turn off this behavior, and slightly improve performance, using the `decryptPostSave` option.\n```\nuserSchema.plugin(encrypt, { ..., decryptPostSave: false });\n...\njoe = new User ({ name: 'Joe', age: 42 });\njoe.save(function(err){\n  console.log(joe.name); // undefined\n  console.log(joe.age); // undefined\n  console.log(joe._ct); // <Buffer 61 41 55 62 33 ...\n});\n```\n\n### Secret String Instead of Two Keys\n\nFor convenience, you can also pass in a single secret string instead of two keys.\n```\nvar secret = process.env.SOME_LONG_UNGUESSABLE_STRING;\nuserSchema.plugin(encrypt, { secret: secret });\n```\n\n\n### Changing Options\nFor the most part, you can seemlessly update the plugin options. This won't immediately change what is stored in the database, but it will change how documents are saved moving forwards.\n\nHowever, you cannot change the following options once you've started using them for a collection:\n- `secret`\n- `encryptionKey`\n- `signingKey`\n- `collectionId`\n\n### Instance Methods\n\nYou can also encrypt, decrypt, sign, and authenticate documents at will (as long as the model includes the plugin). `decrypt`, `sign`, and `authenticate` are all idempotent. `encrypt` is not.\n\n```\njoe = new User ({ name: 'Joe', age: 42 });\njoe.encrypt(function(err){\n  if (err) { return handleError(err); }\n  console.log(joe.name); // undefined\n  console.log(joe.age); // undefined\n  console.log(joe._ct); // <Buffer 61 41 55 62 33 ...\n\n  joe.decrypt(function(err){\n    if (err) { return handleError(err); }\n    console.log(joe.name); // Joe\n    console.log(joe.age); // 42\n    console.log(joe._ct); // undefined\n  });\n});\n\n```\n\n```\njoe.age = 30\n\njoe.sign(function(err){\n  if (err) { return handleError(err); }\n  console.log(joe.name); // Joe\n  console.log(joe.age); // 30\n  console.log(joe._ac); // <Buffer 61 fa 63 95 50\n\n  joe.authenticate(function(err){\n    if (err) { return handleError(err); }\n    console.log(joe.name); // Joe\n    console.log(joe.age); // 30\n    console.log(joe._ac); // <Buffer 61 fa 63 95 50\n\n    joe.age = 22\n\n    joe.authenticate(function(err){ // authenticate without signing changes, error is passed to callback\n    \tif (err) { return handleError(err); } // this conditional is executed\n    \tconsole.log(joe.name); // this won't execute\n  });\n});\n```\nThere are also `decryptSync` and `authenticateSync` functions, which execute synchronously and throw if an error is hit.\n\n\n## Getting Started with an Existing Collection\nIf you are using mongoose-encryption on an empty collection, you can immediately begin to use it as above. To use it on an existing collection, you'll need to either run a migration or use less secure options.\n\n### The Secure Way\nTo prevent tampering of the documents, each document is required by default to have a signature upon `find`. The class method `migrateToA()` encrypts and signs all documents in the collection. This should go without saying, but **backup your database** before running the migration below.\n```\nuserSchema.plugin(encrypt.migrations, { .... });\nUser = mongoose.model('User', userSchema);\nUser.migrateToA(function(err){\n    if (err){ throw err; }\n    console.log('Migration successful');\n});\n```\nFollowing the migration, you can use the plugin as above.\n\n### The Quick Way\nYou can also start using the plugin on an existing collection without a migration, by allowing authentication to succeed on documents unsigned documents. This is less secure, but you can always switch to the more secure options later.\n```\nuserSchema.plugin(encrypt, { requireAuthenticationCode: false, .... });\n```\n\n## Migrating from Versions ≤ 0.11.0\nIf you're using an earlier version of mongoose-encryption, it is recommended that you upgrade. This version adds authentication, without which an attacker with write access to your database may be able to decrypt documents they should not otherwise be able to access, depending on the details of your application.\n\n- Resolve breaking changes\n    - Rename `key` -> `encryptionKey`\n    - Add `signingKey` as 64-byte base64 string (generate with `openssl rand -base64 64`)\n    - Run migrations\n        - If you have encrypted subdocuments, first run the class method `migrateSubDocsToA()` on the parent collection\n\n          ```\n          // Only if there are encrypted subdocuments\n          // Prepends plugin version to _ct\n          userSchema.plugin(encrypt.migrations, { .... });\n          User = mongoose.model('User', userSchema);\n          User.migrateSubDocsToA('locationsOfGold', function(err){\n              if (err){ throw err; }\n              console.log('Subdocument migration successful');\n          });\n          ```\n\n        - Run the class method `migrateToA()` on any encrypted collections (that are not themselves subdocuments)\n\n          ```\n          // Prepends plugin version to _ct and signs all documents\n          userSchema.plugin(encrypt.migrations, { .... });\n          User = mongoose.model('User', userSchema);\n          User.migrateToA(function(err){\n              if (err){ throw err; }\n              console.log('Migration successful');\n          });\n          ```\n\n- Suggestions\n    - Set `additionalAuthenticatedFields` to include, at minimum, all fields involved in authorizing access to a document in your application\n    - If using encrypted subdocuments, note additional recommendations [here](#encrypt-specific-fields-of-sub-docs)\n- Deprecations\n    - Rename `fields` -> `encryptedFields`\n    - Rename `exclude` -> `excludeFromEncryption`\n\n## Pros & Cons of Encrypting Multiple Fields at Once\n\nAdvantages:\n- All Mongoose data types supported via a single code path\n- Faster encryption/decryption when working with the entire document\n- Smaller encrypted documents\n\nDisadvantages:\n- Cannot select individual encrypted fields in a query nor unset or rename encrypted fields via an update operation\n- Potentially slower in cases where you only want to decrypt a subset of the document\n- Transactions including the entire encrypted/authenticated block are effectively enforced. Updating any encrypted or authenticated field forces them all to be marked as modified.\n\n\n## Security Notes\n\n- Always store your keys and secrets outside of version control and separate from your database. An environment variable on your application server works well for this.\n- Additionally, store your encryption key offline somewhere safe. If you lose it, there is no way to retrieve your encrypted data.\n- Encrypting passwords is no substitute for appropriately hashing them. [bcrypt](https://github.com/ncb000gt/node.bcrypt.js) is one great option. Here's one [nice implementation](http://blog.mongodb.org/post/32866457221/password-authentication-with-mongoose-part-1). Once you've already hashed the password, you may as well encrypt it too. Defense in depth, as they say. Just add the mongoose-encryption plugin to the schema after any hashing middleware.\n- If an attacker gains access to your application server, they likely have access to both the database and the key. At that point, neither encryption nor authentication do you any good.\n\n\n## How to Run Unit Tests\n\n0. Install dependencies with `npm install` and [install mongo](http://docs.mongodb.org/manual/installation/) if you don't have it yet\n1. Start mongo with `mongod`\n2. Run tests with `npm test`\n\n\n## Security Issue Reporting / Disclaimer\n\nNone of the authors are security experts. We relied on accepted tools and practices, and tried hard to make this tool solid and well-tested, but nobody's perfect. Please look over the code carefully before using it (and note the legal disclaimer below). **If you find or suspect any security-related issues, please email us at security@cinchfinancial.com** and we will get right on it. For non-security-related issues, please open a Github issue or pull request.\n\n## Acknowledgements\n\nHuge thanks goes out to [Cinch Financial](https://www.cinchfinancial.com) for supporting this plugin through version 1.0, as well as [@stash](//github.com/stash) for pointing out the limitations of earlier versions which lacked authentication and providing invaluable guidance and review on version 0.12.0.\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2014-2015 Joseph Goldbeck and Connect Financial, LLC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
  "readmeFilename": "README.md",
  "_id": "mongoose-encryption@1.1.0",
  "dist": {
    "shasum": "07c43981ff3feb607a4344762b548c53d1f05ead"
  },
  "_from": "mongoose-encryption@",
  "_resolved": "https://registry.npmjs.org/mongoose-encryption/-/mongoose-encryption-1.1.0.tgz"
}
