"use strict";

/**
 *  require modules needed
 */
var request = require("request");
var path = require('path');
var fs = require('fs');
var io;
var duplicateCode = require('./duplicatecode').nodeDuplicateCode;
duplicateCode = new duplicateCode();
function nodeCodeReviewEngine() {
    return new CodeReviewEngine();
}
var async = require("async");
function CodeReviewEngine() {

}
/******************************************************************** Distributed Architecture **************************************************************/


CodeReviewEngine.prototype.startCodeReviewEngine = function (params, callback) {
    try {
        console.log('** START ::==> W1.CodeReviewEngine.prototype.startCodeReviewEngine');
        
        //params.messageText = "/visualstudio get file " + params.emitData.file.path.replace('$', '');
        params.messageText = "/visualstudio get filecontent by URL " + params.emitData.file.url;
        doCodeReviewProcess(params, _gConfig, _pullPushCommand, function (res) {
            if (res.statusCode) {
                callback({ statusCode: 100, changeSetID: params.emitData.file.changeSetID });
            }
            else {
                
                var downloadedFilePath = res.downloadedFilePath;
                
                params.downloadContent = {};
                params.downloadContent.metaData = res.status;
                params.downloadContent.path = res.downloadedFilePath;
                params.downloadContent.physicalFilePath = res.downloadedPhysicalFilePath;
                params.downloadContent.noOfLinesInFile = res.noOfLinesInFile;
                
                applyCodeReviewRulesOnFile(params, _gConfig, _pullPushCommand, function (res) {
                    if (res.statusCode) {
                        callback({ statusCode: res.statusCode, errorMessage: res.errorMessage });
                    }
                    else {
                        params.isFileCritical = res.status.isFileCritical;
                        params.codeReviewComments = res.status.codeReviewComments;
                        params.ruleTypeCounts = res.status.ruleTypeCounts;
                        saveCodereviewComments(params, callback);
                    }
                });
            }
        });
    }
    catch (err) {
        console.log('@@ INSIDE CATCH :: => W1. CodeReviewEngine.prototype.startCodeReviewEngine ', err);
        callback({ statusCode: 500, errorMessage: err });
    }
}

/*******************************************************************************************************************************************************/

//Apply code review rules on file.
function applyCodeReviewRulesOnFile(params, gConfig, pullPushCommand, callback) {
    console.log('==> START :: ==> W1 :: ==> CodeReviewEngine.applyCodeReviewRulesOnFile *****************************');
    var pathExtention = path.extname(params.emitData.file.path);
    if (pathExtention === '.js') {
        console.log("*** applyCodeReviewRulesOnFile=>Found .js file ===================>");
        params.type = 'jslint';
    }
    else if (pathExtention === '.css') {
        console.log("*** applyCodeReviewRulesOnFile=>Found .css file ===================>");
        params.type = 'csslint';
    } else if (pathExtention === '.cs') {
        console.log("*** applyCodeReviewRulesOnFile=>Found .cs file ===================>");
        params.type = 'csharpstylecop';
    }
    if (params !== '') {
        params.messageText = "/jslint get codereviewcomments by filecontent";
        doCodeReviewProcess(params, gConfig, pullPushCommand, callback);
    }
}

function saveCodereviewComments(params, saveCodereviewCommentsCallback) {
    try {
        console.log("START :: ==> W1 :: ==> CodeReviewEngine.saveCodereviewComments --------- filePath ============>" + params.emitData.file.path);
        
        var ObjResponse = {};
        ObjResponse.statusCode = 0;
        
        var saveCodeReviewCommentRes = new _gConfig.Codereviewcomments();
        
        saveCodeReviewCommentRes.changesetId = params.emitData.file.changeSetID;
        saveCodeReviewCommentRes.author = params.emitData.file.author;
        saveCodeReviewCommentRes.changeLog = params.emitData.file.changeSetLog;
        saveCodeReviewCommentRes.modifiedDate = params.emitData.file.channgeSetModifyDate;
        saveCodeReviewCommentRes.projectId = params.emitData.header.projectID;
        saveCodeReviewCommentRes.organizationID = params.emitData.header.organizationID;
        saveCodeReviewCommentRes.repository = params.emitData.header.projectName;
        
        saveCodeReviewCommentRes.fileName = params.emitData.file.path;
        
        
        saveCodeReviewCommentRes.comments = params.codeReviewComments;
        
        saveCodeReviewCommentRes.save(function (err, saveCodeReviewCommentResponse) {
            if (err) {
                console.log("@@ ::===> CodeReviewEngine.saveCodereviewComments errrrr====>" + err);
                saveCodereviewCommentsCallback({ statusCode: 100, errorMessage: 'Error while Saving codereview comments...', changeSetID: params.emitData.file.changeSetID });
            }
            else if (saveCodeReviewCommentResponse) {
                console.log("** Success ::==> saveCodeReviewCommentsParams.params.changesetId:=>" + params.emitData.file.changeSetID);
                
                /*************************** Create emitData for Web Publish ****************************************************/
                var emitData = {};
                emitData.projectID = params.emitData.header.projectID;
                emitData.fileID = params.emitData.file._id;
                
                emitData.organizationID = params.emitData.header.organizationID;
                emitData.userIntegrationID = params.emitData.header.userIntegrationID;
                emitData.status = 'codereview_done';
                
                emitData.path = params.emitData.file.path;
                emitData.changeSetID = params.emitData.file.changeSetID;
                emitData.author = params.emitData.file.author;
                emitData.changeSetLog = params.emitData.file.changeSetLog;
                emitData.channgeSetModifyDate = params.emitData.file.channgeSetModifyDate;
                
                emitData.isFileCritical = params.isFileCritical;
                emitData.ruleTypeCounts = params.ruleTypeCounts;

                emitData.comments = params.codeReviewComments;
                emitData.serverEvent = 'newFileCodeReviewed';
                
                var emitMessage = { action: 'message', organizationID: params.emitData.header.organizationID, emitData: emitData };
                emitMessage = JSON.stringify(emitMessage);
                
                //Save Code Review Comments In Redis
                var messageScore = getDateString(new Date().toUTCString());
                var codeReviewCommentsKey = 'codeReviewComments_' + params.emitData.header.organizationID + '_' + params.emitData.header.projectID;
                try {
                    _gConfig.redisClient.zadd(codeReviewCommentsKey, emitData, messageScore);
                } catch (err) {
                    console.log(err);
                }
                
                //Emit data to web for compile notification.
                _allModule.SocketModule.publish(emitMessage, function (res) {

                });
                
                saveCodereviewCommentsCallback({ statusCode: 0, codeReviewComments: saveCodeReviewCommentResponse.comments, isFileCritical: params.isFileCritical, ruleTypeCounts: params.ruleTypeCounts });
            }
            else {
                saveCodereviewCommentsCallback({ statusCode: 100, errorMessage: 'Error while Saving codereview comments...', changeSetID: params.emitData.file.changeSetID });
            }
        });
        
    } catch (err) {
        console.log("ERR :: Inside saveCodereviewCommentsV1  ============>" + JSON.stringify(err));
        saveCodereviewCommentsCallback({ statusCode: 100, "errorMessage": err });
        return;
    }
}

function getDateString(date) {
    try {
        if (typeof date == 'undefined' || date == -1 || date == 0) {
            date = new Date();
        } else {
            date = new Date(date);
        }
        return date.getTime();
    } catch (err) {
        console.log(err, 'getDateString');
    }
    /* var year = date.getUTCFullYear().toString(),
     month = date.getUTCMonth() + 1,
     day = date.getUTCDate();
     var newDate = year + month + day;*/
}

function doCodeReviewProcess(params, gConfig, pullPushCommand, callback) {
    try {
        emitCommandData(params, gConfig, pullPushCommand, callback);
    }
    catch (err) {
        console.log('doCodeReviewProcess==========>', err);
        callback({ statusCode: 100 });
    }
}

//Emit command data to user or group member
function emitCommandData(params, gConfig, pullPushCommand, callback) {
    try {
        var spitDataArray = params.messageText.split(' ');
        var DataArray = spitDataArray;
        var integrationName = spitDataArray[0];
        integrationName = integrationName.replace('/', '');
        //var params = {};
        params.data = {
            UserID: params.senderUserID,
            OrganizationID: params.organizationID,
            IntegrationName: integrationName,
            DataArray: DataArray,
            TargetID: params.targetID,
            CommmandID: params.commmandID,
            TargetType: params.targetType,
            organizationProject: params.orgProject
        };
        runCommand(gConfig, pullPushCommand, params, function (result) {
            params.parseHtml = 1;
            if (result.statusCode) {
                callback({ statusCode: 100, statusMessage: result.statusMessage, errorMessage: result.errorMessage });

            } else {
                callback(result);
            }
        });
    } catch (err) {
        console.log(" EEEEEEE RRRRRRRRRRR");
        console.log(err.stack);
        callback({ statusCode: 100 });
    }
}

//To run the pull push command
function runCommand(gConfig, pullPushCommand, params, callback) {
    console.log("WE ARE IN RUN COMAND");
    try {
        params.data.DataArray = CreateCommandArray(params.data.DataArray);
        var command = params.data.DataArray[0];
        if (typeof (params.data.DataArray[1]) != 'undefined' && params.data.DataArray[1] != '') {
            command += ' ' + params.data.DataArray[1];
        }
        var ActualCommand = command;
        if ((params.data.IntegrationName == "appear" || params.data.IntegrationName == "gotomeeting" || params.data.IntegrationName == "giphy") && (params.data.DataArray[1] != 'help')) {
            command = params.data.DataArray[0];
        }
        var ThreeLetterCommandArr = ["recurly", "insight", "smartsheet", "force", "visualstudio", "paper", "scoutapp", "site24", "samanage", "jive", "chargebee", "robot", "chargify", "clearbit", "relateiq", "lighthouse", "jixee", "highrise", "agile", "groove", "postmark", "scout", "digitalocean", "site", "teamsupport", "freshservice", "tender", "onelogin", "dns", "mandrill", "optimize", "done", "reamaze", "cloud", "woopra", "scoutapp", "airbrake", "victor", "preact", "plivo", "satisfaction", "base", "city", "timecamp", "testlodge", "swift", "postmark", "keen", "iron", "firbase", "dploy", "customerio", "okta", "gitlab", "sprintly", "gemini", "testrail", "victor", "airbrake", "base", "loader", "runscope", "feedbin", "go", "copper", "snappy", "stripe", "fresh", "boundary", "bugsnag", "com", "bee", "enchant", "tracker", "ping", "bean", 'kite', 'circle', 'ship', 'librato', 'sema', 'page', 'dog', 'scout', 'magnum', 'duty', 'relic', 'fresh', 'voice', 'copper', 'spm', 'density', 'desk', 'snappy', 'sentry', 'runscope', 'hub', 'jira', 'ping', 'codejenie', 'jslint'];
        
        if (ThreeLetterCommandArr.indexOf(params.data.IntegrationName) > -1 && params.data.DataArray[1] != 'help') {
            command += ' ' + params.data.DataArray[2];
        }
        console.log("******** Before getIntegrationApisDataFromRedis *************");
        gConfig.getIntegrationApisDataFromRedis(params.data.CommmandID, command, function (IntegrationApisData) {
            console.log("******** getIntegrationApisDataFromRedis *************");
            //console.log(IntegrationApisData);
            if (IntegrationApisData != null) {
                console.log("******** IntegrationApisData !=null getIntegrationApisDataFromRedis *************");
                var FunctionName = IntegrationApisData.functionName;
                console.log(FunctionName);
                if (params.data.DataArray[1] == 'help') {
                    functionName = 'GetHelp';
                }
                pullPushCommand[FunctionName](IntegrationApisData, io, gConfig, params, CommandCallBack.bind(null, ActualCommand, IntegrationApisData, io, gConfig, params, callback));
            } else {
                callback({ statusCode: 100, Status: ActualCommand + ' ' + 100 });
            }
        });
    } catch (err) {
        console.log('RunCommand==========>', err);
        callback({ statusCode: 100, Status: ActualCommand + ' ' + ' ' });
    }
}

function CommandCallBack(ActualCommand, IntegrationApisData, io, gConfig, params, callback, result) {
    try {
        
        //var DataObject = { integrationApisID: IntegrationApisData._id, userIntegrationID: params.data.UserID, success: "success", error: "", lastTime: new Date(), data: result.status, webHook: false };
        //var IntegrationApisLogsObj = new gConfig.IntegrationApisLogs(DataObject);
        //IntegrationApisLogsObj.save(function (err, IntegrationApisLogsData) {
        //});
        //console.log('CommandCallBack.result======>' + IntegrationApisData.command + ' ' + JSON.stringify(result) + '' + params.orgProject.projectId + '<->' + params.orgProject.projectName);
        console.log('CommandCallBack.result======>');
        
        if (IntegrationApisData.command === '/visualstudio get filecontent' && !result.statusCode) {
            try {
                console.log('** START DOWNNLOADEDING FILE ON LOCAL SYSTEM -------->' + params.emitData.header.organizationID + '\\' + params.emitData.header.projectID + '\\' + params.emitData.file._id);
                var fileExtention = path.extname(params.emitData.file.path);
                if (fileExtention.toLowerCase() === '.js' || fileExtention.toLowerCase() === '.css' || fileExtention.toLowerCase() === '.cs') {
                    
                    var DOWNLOAD_DIR = '.\\downloads\\' + params.emitData.header.organizationID;
                    if (!fs.existsSync(DOWNLOAD_DIR)) {
                        console.log('** Create a new Directory ::==>', DOWNLOAD_DIR);
                        var res = fs.mkdirSync(DOWNLOAD_DIR);
                    } else {
                        console.log('** Directory already exist ::==>', DOWNLOAD_DIR);
                    }
                    
                    DOWNLOAD_DIR = DOWNLOAD_DIR + '\\' + params.emitData.header.projectID;
                    
                    if (!fs.existsSync(DOWNLOAD_DIR)) {
                        console.log('** Create a new Directory ::==>', DOWNLOAD_DIR);
                        fs.mkdirSync(DOWNLOAD_DIR);
                    }
                    else {
                        console.log('** Directory already exist ::==>', DOWNLOAD_DIR);
                    }
                    
                    var downloadedFile = fs.createWriteStream(DOWNLOAD_DIR + '\\' + params.emitData.file._id + path.extname(params.emitData.file.path));
                    downloadedFile.write(result.status);
                    downloadedFile.end();
                    
                    result.downloadedFilePath = downloadedFile.path;
                    result.downloadedPhysicalFilePath = _workingDirectory + downloadedFile.path.substring(1, downloadedFile.path.length);
                    
                    var noOfLinesInFile = result.status.split('\n').length;
                    result.noOfLinesInFile = noOfLinesInFile;
                } else {
                    console.log('** INVALID EXTENTION FOR DOWNNLOADEDING FILE ON LOCAL SYSTEM -------->' + params.emitData.header.organizationID + '\\' + params.emitData.header.projectID + '\\' + params.emitData.file._id);
                }
            } catch (err) {
                console.log('@@ INSIDE CATCH DOWNLOADED FILE ON LOCAL SYSTEM -------->' + err);
            }
        }
        
        result.command = IntegrationApisData.command;
        result.callbackParams = params;
        
        callback(result);
         
    } catch (err) {
        console.log('commandcallback==========>', err);
        callback({ statusCode: 100, Status: ActualCommand + ' ' + 100 });
    }
}

function CreateCommandArray(CommandArr) {
    try {
        var IsMultipleWord = false;
        var CommandArrTemp = [];
        var MultipleWord = '';
        var QuotCounter = -1;
        CommandArr.forEach(function (ArrElement, Index) {
            //Array Element Contains Single or Duble quot append all these words and push all element as single
            if (ArrElement != '' && ArrElement != null) {
                if (ArrElement.indexOf('"') > -1 || ArrElement.indexOf('&#039;') > -1 || ArrElement.indexOf("'") > -1 || IsMultipleWord == true) {
                    MultipleWord += ArrElement + ' ';
                    if (ArrElement.indexOf("'") > -1 || ArrElement.indexOf('"') > -1 || ArrElement.indexOf('&amp;quot;') > -1) {
                        QuotCounter += 1;
                    }
                    //If quot ends push words in array               
                    if (QuotCounter == 1) {
                        IsMultipleWord = false;
                        CommandArrTemp.push(MultipleWord)
                        MultipleWord = "";
                        QuotCounter = -1;
                    } else {
                        IsMultipleWord = true;
                    }
                } else {
                    CommandArrTemp.push(ArrElement);
                }
            }

        });
        //console.log("CommandArrTemp rrrrrrrrrrrrrrrrrrrrrrrrr @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2");
        //console.log(CommandArrTemp);
        return CommandArrTemp;
    } catch (err) {
        console.log("Error In CreateCommandArray Function");
        console.log(err.stack);
    }
}




// Verify Extention of file pass it for parssing
function getCommonCodeForFile(pathExtention, filePath, fileContents, gConfig, projectID, getCommonCodeForFileCallback) {
    try {
        console.log("WE are in getCommonCodeForFile");
        console.log(pathExtention);
        if (pathExtention === '.cs') {
            var GenerateCSMap = require('./GenerateCsMap.js').GenerateCSMap;
            var GenerateCSMap = new GenerateCSMap();
            // globalVariables = [];
            // globalVariableDict = [];
            var isFileChange = false;
            var filedetails = { fullpath: filePath, filename: "Members.aspx.cs", name: "Members.aspx.cs", fileContent: fileContents }
            var changedLines = [];
            GenerateCSMap.parseFile(filedetails, isFileChange, changedLines, getFileParsingCallback.bind(null, gConfig, projectID, getCommonCodeForFileCallback));
        }
        //getCommonCodeForFileCallback({status:0,commonCode:{}})
    } catch (err) {
        gConfig.writeErrorLog("getCommonCodeForFile", err.stack);
    }
    
    
}

// Get the file parsing result and store it in database
function getFileParsingCallback(gConfig, projectID, getCommonCodeForFileCallback, parsingResult) {
    try {
        if (typeof (parsingResult) != 'undefined' && parsingResult != null) {
            console.log("WE are in getparsingResult");
            var fileBlockObj = {};
            fileBlockObj.fileName = parsingResult.filename
            fileBlockObj.filePath = parsingResult.filePath;
            fileBlockObj.fileMap = parsingResult.Map;
            fileBlockObj.fileBlocks = parsingResult.blocks;
            fileBlockObj.functionBlocks = parsingResult.functionBlocks;
            fileBlockObj.ifElseBlocks = parsingResult.ifElseBlocks;
            fileBlockObj.projectID = projectID;
            var resProjectMap = new gConfig.ProjectMap(fileBlockObj);
            gConfig.ProjectMap.update({ projectID: projectID, filePath : parsingResult.filePath }, { $set: { fileMap: parsingResult.Map, fileName: parsingResult.filename, filePath: parsingResult.filePath , projectID: projectID, fileBlocks: parsingResult.blocks, functionBlocks: parsingResult.functionBlocks, ifElseBlocks: parsingResult.ifElseBlocks } }, { upsert: true }, insertProjectMapCallback.bind(null, gConfig, projectID, fileBlockObj, getCommonCodeForFileCallback));
            //getCommonCodeForFileCallback({status:0,commonCode:commonCodeResult})

            /*function (err, response) {
               
            });     */
        } else {
            getCommonCodeForFileCallback({ status: 100, commonCode: {} });
        }
    } catch (err) {
        console.log("Error in getFileParsingCallback", err.stack)
        gConfig.writeErrorLog("getFileParsingCallback", commonCodeResult);
    }
}

//Append Comman Code Review comments in JsLint/Other Code review comments 
function appendCommonCodereviewComments(pathExtention, codeReviewResult, commonCodeReviewResult) {
    try {
        console.log("we are in appendCommonCodereviewComments");
        console.log(commonCodeReviewResult);
        console.log("we are in END appendCommonCodereviewComments");
        console.log("pathExtention");
        console.log(pathExtention);
    } catch (err) {
        console.log("Error in appendCommonCodereviewComments", err.stack)
        gConfig.writeErrorLog("appendCommonCodereviewComments", err.stack);
    }
}

//Insert File Map and blocks in database callback
function insertProjectMapCallback(gConfig, projectID, parsingResult, getCommonCodeForFileCallback, error, response) {
    try {
        if (error != null) {
            gConfig.writeErrorLog("getFileBlocksCallback", "unable to save/update data in mongo db");
        } else {
            duplicateCode.getDuplicateCodeBlocks(gConfig, projectID, parsingResult, getCommonCodeForFileCallback);
        }
    } catch (err) {
        console.log("Error in insertProjectMapCallback", err.stack)
        gConfig.writeErrorLog("insertProjectMapCallback", err.stack);
    }
}
module.exports.nodeCodeReviewEngine = nodeCodeReviewEngine;

