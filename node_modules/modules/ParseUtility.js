	require('sylvester');
	ParseUtility = function() {

	}

	ParseUtility.prototype.getDuplicateCodes = function(blocks) {

		var outerCount = 0;
		blocks.forEach( function (blockObj) {
			
			// compare only chnaged blockes with other blocks			 
		//	if( blockObj.islinechanged == true ) {
				var query = blockObj.block.trim();
				var tokens = query.split(" ");
				var blockTokens = tokens.filter(function(elem, index, self) {
			    	return index == self.indexOf(elem);
				});
				blockTokens  = blockTokens.sort();
		       	var tempVector =  new Array();
		       	var queryValueVector = GetVector(blockTokens, query,tempVector);
		       	var npqueryValueVector = $V(queryValueVector);
		        var queryVector = blockTokens;
		        blocks.forEach( function (remainingBlockObj) {
		        	if( blockObj.block != remainingBlockObj.block) {
		        		//get the vector for the block        		
		    			var doc =  remainingBlockObj.block.trim();
		    			
		    			var tempVector =  new Array();
		                var vector = GetVector(queryVector, doc ,tempVector);
		                
		                var  npVector = $V(vector);							
		               	var  dotProduct = npqueryValueVector.dot(npVector);		                  
		               
		                var l2normVector = L2Norm(npVector);
		             	
		                var l2normQueryValueVector= L2Norm(npqueryValueVector);
		                if(l2normVector != 0  && l2normQueryValueVector != 0 ) {
		                	var cosineSimilarity =( ( dotProduct )/( l2normVector*l2normQueryValueVector ) );
		                } else {
		                	var cosineSimilarity = 0;
		                }		
		                console.log("cosineSimilarity ***"+cosineSimilarity);                    
		                //key = outerCount+"_"+innerCount;
		                if(cosineSimilarity > 0.80 ) {             	
		                	var commonCodeObj = { "Block1" : blockObj.block, "Block2" : remainingBlockObj.block};
		                   // var commonCodeObj1.push(commonCodeObj);
		                    CodeReviewComments[outerCount] = commonCodeObj;
		                    outerCount+=1;
		                }
		    		}
		        });
			//}
			
		});
		return CodeReviewComments;
	}

 	 //Get vaector of string
	function GetVector(query_vector, value, vector ){
		var i = 0;
		var is_append = false;
		if(vector.length == 0){
			is_append = true;			
		}
		query_vector.forEach( function ( term ){
			if(is_append){
				vector.push(0);
			}
			var valueArr = value.split(" ");
			valueArr.forEach( function ( word ){
				if (word == term) {
					 vector[i] += 1;
				}
			});
			i += 1
		});
		return vector
	}

	function L2Norm(cent){
		var norm = cent.norm();
		return 	norm;	
	}

	ParseUtility.prototype.getDuplicateCodesFromOtherFiles = function(searchBlocks,otherFileblocks,gConfig) {
		//console.log("searchBlocks >>>>>>>>>>>>>>>>>>"+searchBlocks);
		try {
			CodeReviewComments = [];
			var query = searchBlocks.trim();
			var tokens = query.split(" ");
			var blockTokens = tokens.filter(function(elem, index, self) {
		    	return index == self.indexOf(elem);
			});
			blockTokens  = blockTokens.sort();
	       	var tempVector =  new Array();
	       	var queryValueVector = GetVector(blockTokens, query,tempVector);
	       	var npqueryValueVector = $V(queryValueVector);
	        var queryVector = blockTokens;

	        //var parsdFileBlocks= JSON.parse(otherFileblocks);
	        var parsdFileBlocks= otherFileblocks;
		  	var parsdFileBlocksKeys = Object.keys(parsdFileBlocks);
			var outerCount = 0
			for (var key in parsdFileBlocksKeys ) {

	    		//get the vector for the block        		
				var doc =  parsdFileBlocks[key]["block"].trim();		
				var tempVector =  new Array();
	            var vector = GetVector(queryVector, doc ,tempVector);
	            
	            var  npVector = $V(vector);							
	           	var  dotProduct = npqueryValueVector.dot(npVector);		                  
	           
	            var l2normVector = L2Norm(npVector);
	         	
	            var l2normQueryValueVector= L2Norm(npqueryValueVector);
	            if(l2normVector != 0  && l2normQueryValueVector != 0 ) {
	            	var cosineSimilarity =( ( dotProduct )/( l2normVector*l2normQueryValueVector ) );
	            } else {
	            	var cosineSimilarity = 0;
	            }		
	            console.log("cosineSimilarity ***"+cosineSimilarity);                    
	           
	            if(cosineSimilarity > 0.80 ) {       	
	            	var commonCodeObj = {"CodeBlock" : parsdFileBlocks[key]["block"],"Line" : parsdFileBlocks[key]["Line"] };	                   
	                CodeReviewComments[outerCount] = commonCodeObj;
	                outerCount+=1;
	            }

			}
			return CodeReviewComments;
		} catch (err){
			console.log("Error in getDuplicateCodesFromOtherFiles",err.stack);
			gConfig.writeErrorLog("getDuplicateCodesFromOtherFiles",err.stack);
		}
		
	}

	ParseUtility.prototype.getDuplicateCodesInSameFile = function(searchBlocks,otherFileblocks,id,gConfig) {
    	try {		
			console.log("searchBlocks >>>>>>>>>>>>>>>>>>"+searchBlocks);
			CodeReviewComments = [];
			var query = searchBlocks.trim();
			var tokens = query.split(" ");
			var blockTokens = tokens.filter(function(elem, index, self) {
		    	return index == self.indexOf(elem);
			});
			blockTokens  = blockTokens.sort();
	       	var tempVector =  new Array();
	       	var queryValueVector = GetVector(blockTokens, query,tempVector);
	       	var npqueryValueVector = $V(queryValueVector);
	        var queryVector = blockTokens;
	       // var parsdFileBlocks= JSON.parse(otherFileblocks);
	         var parsdFileBlocks = otherFileblocks;	         
		  	var parsdFileBlocksKeys = Object.keys(parsdFileBlocks);		  	
			var outerCount = 0
			for (var key in parsdFileBlocksKeys ) {				
				if(id != key) {
					//get the vector for the block        		
					var doc =  parsdFileBlocks[key]["block"].trim();		
					var tempVector =  new Array();
		            var vector = GetVector(queryVector, doc ,tempVector);
		            
		            var  npVector = $V(vector);							
		           	var  dotProduct = npqueryValueVector.dot(npVector);		                  
		           	            var l2normVector = L2Norm(npVector);
		         	
		            var l2normQueryValueVector= L2Norm(npqueryValueVector);
		            if(l2normVector != 0  && l2normQueryValueVector != 0 ) {
		            	var cosineSimilarity =( ( dotProduct )/( l2normVector*l2normQueryValueVector ) );
		            } else {
		            	var cosineSimilarity = 0;
		            }		
		            console.log("cosineSimilarity ***"+cosineSimilarity); 
		            if(cosineSimilarity > 0.80 ) {       	
		            	var commonCodeObj = { "CodeBlock" : parsdFileBlocks[key]["block"],"Line" : parsdFileBlocks[key]["Line"] };	                   
		                CodeReviewComments[outerCount] = commonCodeObj;
		                outerCount+=1;
		            }
				}
			}
			return CodeReviewComments;
		} catch (err) {
			console.log("Error in getDuplicateCodesInSameFile",err.stack);
			gConfig.writeErrorLog("getDuplicateCodesInSameFile",err.stack);
		}
	}

	
	exports.ParseUtility = ParseUtility;