"use strict";

/**
 * @Easy and simple way of communication between DuplicateCode with nodeJS
 * @author Aloha
 */

/**
 *  require modules needed
 */
var request  = require("request");

//var async = require("async");
/**
 * Create DuplicateCode instance
 * @param {type} token
 * @returns {DuplicateCode}
 */
 var changedFilesArr = [
  '$/CSharpProject/PhoneBook.aspx.cs',
  '$/CSharpProject/Members.aspx.cs'
 ]
var ParseUtility = require('./ParseUtility.js').ParseUtility;
var ParseUtility = new ParseUtility();
function nodeDuplicateCode(options) {
    return new DuplicateCode(options);
}

function DuplicateCode(options) {
  
}

// make array of file list present in database
function makeFileList(gConfig,parsingResult,functionCallback,error,allFilesBlock) {
	var duplicateBlocksPerFile = [];	
	var blockTypeArr = ["functionBlocks","fileBlocks","ifElseBlocks"];	
	console.log("parsingResult DSFSAFS");
	console.log(allFilesBlock.length);
	console.log("ERERERE");
	try {
		if( typeof(allFilesBlock) != 'undefined' && allFilesBlock != null ) {
			var duplicateBlocksPerBlock = [];
			gConfig.async.each(blockTypeArr, function(blockType,eachCallback) {
				var searchSingleFileBlocksObj = parsingResult[blockType];
	            console.log("searchSingleFileBlocksObj");
	            console.log(searchSingleFileBlocksObj);
	            searchSingleFileBlocksObj = JSON.parse(searchSingleFileBlocksObj);
	            var blockCounter = -1;	
	            gConfig.async.each(searchSingleFileBlocksObj, function(searchSingleBlock, searchLoopEachCallback){                    
	                blockCounter = blockCounter + 1;
	                console.log("searchSingleBlock qwqwq");
	                console.log(searchSingleBlock);	
	                //Loop through all files
		            gConfig.async.each(allFilesBlock, function(singleFileBlocks, allFilesCallback){
		            	var singleFileBlocksObj = JSON.parse(singleFileBlocks[blockType]);	
		            	// Verify extention of file are same or not
		            	if( gConfig.path.extname(singleFileBlocks.filePath) == gConfig.path.extname(parsingResult.filePath) ) {
		        			//Loop each block of modifiled file
		        			 if(typeof(searchSingleBlock.block) != 'undefined' && searchSingleBlock.block != '' && searchSingleBlock.block != null) {
								//if file is not same.
								if ( singleFileBlocks.filePath != parsingResult.filePath ) {
									var duplicateBlocks = ParseUtility.getDuplicateCodesFromOtherFiles(searchSingleBlock.block,singleFileBlocksObj,gConfig);
									if( duplicateBlocks.length > 0 ) {
										console.log("duplicateBlocks block aRE "+gConfig.util.inspect(duplicateBlocks));
										var fileWiseDuplicateBlockObj = { FilePath: singleFileBlocks.filePath, DuplicatesForFile : duplicateBlocks };
										var blockObj = { SearchBlock : searchSingleBlock.block, Result: JSON.stringify(fileWiseDuplicateBlockObj),"Line":searchSingleBlock.Line };
										if( typeof duplicateBlocksPerFile == 'undefined') {
											duplicateBlocksPerFile = [];
											duplicateBlocksPerFile.push(blockObj);
										} else {
											duplicateBlocksPerFile.push(blockObj);
										}													
									}
								} else {
									//if file is same.
									var duplicateCodeBlocks = ParseUtility.getDuplicateCodesInSameFile(searchSingleBlock.block,searchSingleFileBlocksObj,blockCounter,gConfig);
									if( duplicateCodeBlocks.length > 0 ) {
										console.log("SELF FILE DUPLICATE BLICKS>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>AAAAAAAAAAAAAAAAAAAA"+ gConfig.util.inspect(JSON.stringify(duplicateCodeBlocks)));
										var fileWiseDuplicateBlockObj = { FilePath: parsingResult.filePath, DuplicatesForFile : duplicateCodeBlocks };
										var blockObj = { SearchBlock : searchSingleBlock.block, Result: JSON.stringify(fileWiseDuplicateBlockObj),"Line":searchSingleBlock.Line };
										if( typeof duplicateBlocksPerFile == 'undefined') {
											duplicateBlocksPerFile = [];
											duplicateBlocksPerFile.push(blockObj);
										} else {
											duplicateBlocksPerFile.push(blockObj);
										}
									}																										
								}
							}
		        			allFilesCallback();
				        } else {
				        	allFilesCallback();
				        }
		            }, function(){
		            	console.log("END OF All File LOOP");		            	
		            	searchLoopEachCallback();
		            });
		        }, function(){		        	
            		console.log("END OF search block LOOP");
            		eachCallback();
		        });
			            
            }, function(){	        	
					console.log(duplicateBlocksPerFile);
					console.log("end of duplicate");
					console.log("END OF Block Type LOOP");
					functionCallback(duplicateBlocksPerFile);
        	});
		} else {
			functionCallback();
		}
	} catch (err) {
		console.log("Error in makeFileList ",err.stack);
		gConfig.writeErrorLog("makeFileList",err.stack);
		functionCallback();
	}	
}	



//Verify Duplicate Code Reviews same file type in whole of project 
function getDuplicateCodeReview(blockType,fileListArr,allFilesBlock,callback) {
	try {
		for ( var filePath in  fileListArr ) {

			//var parsdFileBlocks= JSON.parse(fileListArr[filePath]);
			console.log(fileListArr[filePath]);
			console.log("end of fileListArr[filePath]");
			var parsdFileBlocks= fileListArr[filePath];
		  	var parsdFileBlocksKeys = Object.keys(parsdFileBlocks);		
		  	console.log("parsdFileBlocksKeys are "+parsdFileBlocksKeys);  	
		  	console.log("parsdFileBlocks are "+parsdFileBlocks);  		
			//get each files blocks 
			var duplicateBlocksPerFile = [];
			var duplicateBlocksPerBlock = [];
			for (var key in parsdFileBlocksKeys ) {		
				//if( parsdFileBlocks[key]["islinechanged"] ) {
					
					var searchBlock = parsdFileBlocks[key]["block"];	
					console.log("block>>>>>>>>>>>>>>>>>>>>>>>>>>>>google"+searchBlock);
					console.log("block>>>>>>>>>>>>>>>>>>>>>>>>>>>>"+parsdFileBlocks[key]["Line"]);					
					for ( var duplicateKey in allFilesBlock ) {
						var  sourceFileExt = "" ;
						var destinationFilePath = allFilesBlock[duplicateKey].filePath;
						var extensions = (destinationFilePath.indexOf(".cs") > -1) || (destinationFilePath.indexOf(".php") > -1);
	            		if(extensions) {
							if(process.platform == "linux" ) {
								//source file
								var filePathArr = filePath.split('/');
								sourceFileExtArr = filePathArr[filePathArr.length-1];
								sourceFileExtArr = sourceFileExtArr.split('.');
								sourceFileExt = sourceFileExtArr[sourceFileExtArr.length-1];
								//destination file
								var DestFilePathArr = destinationFilePath.split('/');
								destinationFileExtArr = DestFilePathArr[DestFilePathArr.length-1];
								destinationFileExtArr = destinationFileExtArr.split('.');
								destinationFileExt =	destinationFileExtArr[destinationFileExtArr.length-1];
							} else {
								//source file
								var filePathArr = filePath.split('\\');
								sourceFileExtArr = filePathArr[filePathArr.length-1];
								sourceFileExtArr = sourceFileExtArr.split('.');
								sourceFileExt = sourceFileExtArr[sourceFileExtArr.length-1];
								//destination file
								var DestFilePathArr = destinationFilePath.split('\\');
								destinationFileExtArr = DestFilePathArr[DestFilePathArr.length-1];
								destinationFileExtArr = destinationFileExtArr.split('.');
								destinationFileExt =	destinationFileExtArr[destinationFileExtArr.length-1];
								 
							}
	  						//verify extention
							if( sourceFileExt == destinationFileExt ) {
								if(allFilesBlock[duplicateKey][blockType] != '') {
									//if file is not same.
									if ( filePath != allFilesBlock[duplicateKey].filePath ) {

										var duplicateBlocks = ParseUtility.getDuplicateCodesFromOtherFiles(parsdFileBlocks[key]["block"],allFilesBlock[duplicateKey][blockType]);
										if( duplicateBlocks.length > 0 ) {
											console.log("duplicateBlocks block aRE "+util.inspect(duplicateBlocks));
											var fileWiseDuplicateBlockObj = { FilePath: allFilesBlock[duplicateKey].filePath, DuplicatesForFile : duplicateBlocks };
											if( typeof duplicateBlocksPerBlock[searchBlock] == 'undefined') {
												duplicateBlocksPerBlock[searchBlock] = [];
												duplicateBlocksPerBlock[searchBlock].push(fileWiseDuplicateBlockObj);
											} else {
												duplicateBlocksPerBlock[searchBlock].push(fileWiseDuplicateBlockObj);
											}
										}									
										
									} else {
										//if file is same.
										var duplicateCodeBlocks = ParseUtility.getDuplicateCodesInSameFile(searchBlock,fileListArr[filePath],key);
										if( duplicateCodeBlocks.length > 0 ) {
											//console.log("SELF FILE DUPLICATE BLICKS>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>AAAAAAAAAAAAAAAAAAAA"+ util.inspect(JSON.stringify(duplicateCodeBlocks)));
											
											var fileWiseDuplicateBlockObj = { FilePath: filePath, DuplicatesForFile : duplicateCodeBlocks };
											if( typeof duplicateBlocksPerBlock[searchBlock] == 'undefined') {											
												duplicateBlocksPerBlock[searchBlock] = [];
												duplicateBlocksPerBlock[searchBlock].push(fileWiseDuplicateBlockObj);
											} else {
												duplicateBlocksPerBlock[searchBlock].push(fileWiseDuplicateBlockObj);
											}
										}																										
									}
								}
							}			  					
		  				}					
					}
					if ( typeof duplicateBlocksPerBlock[parsdFileBlocks[key]["block"]] != 'undefined' ) {
						var blockObj = { SearchBlock : parsdFileBlocks[key]["block"], Result: duplicateBlocksPerBlock[parsdFileBlocks[key]["block"]],"Line":parsdFileBlocks[key]["Line"] };
						if( typeof duplicateBlocksPerFile[filePath] == 'undefined') {
							duplicateBlocksPerFile[filePath] = [];
							duplicateBlocksPerFile[filePath].push(blockObj);
						} else {
							duplicateBlocksPerFile[filePath].push(blockObj);
						}
					}									
				//}
			}
			if( typeof duplicateBlocksPerFile[filePath] != 'undefined' ){
				console.log("duplicateBlocksPerFile[filePath] are "+util.inspect(duplicateBlocksPerFile[filePath]))
				var duplicateBlockObj = { FilePath : filePath , DuplicateBlocks: duplicateBlocksPerFile[filePath] };
				duplicateBlockObj = JSON.stringify(duplicateBlockObj);
				duplicateCodeModel.insertDuplicateCode(filePath,duplicateBlockObj,blockType);
			}
						
		}
		setTimeout(function() {
			callback(blockType)
		}, 60000);
	} catch(ex) {
		console.log("error in rrrrrrrrrrrrrr",ex.stack)
	}
	
	//setInterval(callback(blockType),60000);
	//callback(blockType);
}


 

DuplicateCode.prototype.getDuplicateCodeBlocks = function (gConfig,projectID,parsingResult,getDuplicateCodeBlocks) { 
   console.log("WE are in getDuplicateCodeBlocks");
   try {
		gConfig.ProjectMap.find({projectID:projectID},makeFileList.bind(null,gConfig,parsingResult,getDuplicateCodeBlocks));
   	} catch(err) {
   		getDuplicateCodeBlocks();
   		gConfig.writeErrorLog("getDuplicateCodeBlocks",err.stack);
    }
}


module.exports.nodeDuplicateCode = nodeDuplicateCode;

