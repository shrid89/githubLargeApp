    var fs = require('fs'); 	
    var util = require('util');
    var errorLogFilePath = "/home/user/NewCodeReview/errorlog.txt";
    var	globalVariableCount = 0;
    globalVariables = [];
    var async = require("async");
    globalVariableDict = [];
    GenerateCSMap = function() {
        	
    }

    GenerateCSMap.prototype.parseFile = function(file,isFileChange,changedLines,parseFileCallback) {	    	
    	try{
            globalVariables = [];
            variableDict = [];
            parseCodeFileSync(file,isFileChange,changedLines,generateJsonObject.bind(null,file,changedLines,parseFileCallback));
     	} catch (err) {
    	 	fs.appendFile(errorLogFilePath, err+"error in createMap", function (err) {
    		});
    	}
    }


    function generateJsonObject ( file,changedLines,parseFileCallback,classDict, funcDict, codeReviewBlocksDict, codeReviewFunBlocksDict, codeReviewIfElseBlocksDict ) {

    	var filename = file.filename;		
    	var blocks = "";
    	var functionBlocks = "";
    	var ifElseBlocks = "";
    	var path = file.fullpath;
    	var filePath = path.replace( /\/+/g, '/' );	
    	var jsonObject = {};	
    	try{
       		if(globalVariableDict != 'undefined') {
       			jsonObject = {"filename":filename,"globalVariableDict":globalVariableDict,"filePath":filePath,"class":[]};	
       		} else {
       			jsonObject = {"filename":filename,"filePath":filePath,"class":[]};	
       		}
            if(typeof classDict[ file.filename] != 'undefined') {
    	               
    	        var classCount = 0;
                for( var cl in classDict[file.filename] ) {	                
             	
                 	jsonObject.class[classCount] = { "classname": classDict[file.filename][cl]["classname"], "baseclassname": classDict[file.filename][cl]["baseclassname"],"functions":[] };	
                	if(typeof funcDict[classDict[file.filename][cl]["classname"]] != 'undefined') {
                        var funcCount = 0;
                        //get all functions in a class
                        if ( funcDict[classDict[file.filename][cl]["classname"]].length > 0 ) {
                            for (var func in funcDict[classDict[file.filename][cl]["classname"]] ){                                 
                             	//var functionName = funcDict[classDict[file.filename][cl]["classname"]][func]["functionname"];                            	                   				                         		
                     		 	//console.log(" VARIABLE DIC"+util.inspect(variableDict[funcDict[classDict[file.filename][cl]["classname"]][func]["functionname"]]));
                     		 	if(typeof variableDict[funcDict[classDict[file.filename][cl]["classname"]][func]["functionname"]] != 'undefined') {
                     		 		
                     			
                        	   		//console.log("tempObj  ISSSSSSSSSSSSSSSSSS Next"+util.inspect(tempObj))
                        	   		jsonObject.class[classCount].functions[funcCount] = {"functionName":funcDict[classDict[file.filename][cl]["classname"]][func]["functionname"],"functionLineCount":funcDict[classDict[file.filename][cl]["classname"]][func]["functionLineCount"],"functionStartIndex":funcDict[classDict[file.filename][cl]["classname"]][func]["functionStartIndex"],"functioEndIndex":funcDict[classDict[file.filename][cl]["classname"]][func]["functioEndIndex"],"catchCount":funcDict[classDict[file.filename][cl]["classname"]][func]["catchCount"],"tryCount":funcDict[classDict[file.filename][cl]["classname"]][func]["tryCount"],"isFunctionChagned": funcDict[classDict[file.filename][cl]["classname"]][func]["isFunctionChagned"],"cost":funcDict[classDict[file.filename][cl]["classname"]][func]["cost"],"variables":variableDict[funcDict[classDict[file.filename][cl]["classname"]][func]["functionname"]]}; 
                                } else {
                                	 
                        	   		jsonObject.class[classCount].functions[funcCount] = {"functionName":funcDict[classDict[file.filename][cl]["classname"]][func]["functionname"],"functionLineCount":funcDict[classDict[file.filename][cl]["classname"]][func]["functionLineCount"],"functionStartIndex":funcDict[classDict[file.filename][cl]["classname"]][func]["functionStartIndex"],"functioEndIndex":funcDict[classDict[file.filename][cl]["classname"]][func]["functioEndIndex"],"catchCount":funcDict[classDict[file.filename][cl]["classname"]][func]["catchCount"],"tryCount":funcDict[classDict[file.filename][cl]["classname"]][func]["tryCount"],"isFunctionChagned": funcDict[classDict[file.filename][cl]["classname"]][func]["isFunctionChagned"],"cost":funcDict[classDict[file.filename][cl]["classname"]][func]["cost"],"variables":[]};                                    	 
                                }
                              	funcCount +=  1;                                    
    						}
                        }		                  	
                        classCount = classCount + 1;
                    }
    			}		           
    	        	
            }
        } catch (err) {
    	 	fs.appendFile(errorLogFilePath, err+"error in createMap", function (err) {
    		});
    	}
    	if ( typeof codeReviewBlocksDict[file.filename] != 'undefined' ) {
    		blocks = JSON.stringify ( codeReviewBlocksDict[file.filename] );
    	}					
    	if( typeof codeReviewFunBlocksDict[file.filename] != 'undefined' ) {
    		functionBlocks = JSON.stringify(codeReviewFunBlocksDict[file.filename]);
    	}			
    	if( typeof codeReviewIfElseBlocksDict[file.filename] != 'undefined' ) {
    		ifElseBlocks = JSON.stringify(codeReviewIfElseBlocksDict[file.filename]);
    	}
    	
    	var parsedObject = { "Map" : JSON.stringify(jsonObject),"changedLines":changedLines , "filePath":filePath,"filename":filename, "blocks": blocks, "functionBlocks" : functionBlocks,"ifElseBlocks":ifElseBlocks }
    	jsonObject = null;
    	codeReviewBlocksDict = null;
    	codeReviewFunBlocksDict = null; 
    	codeReviewIfElseBlocksDict = null;
        console.log(parsedObject);
        console.log("parsedObject End");
    	parseFileCallback(parsedObject);
    }

    //Parse files 
    function parseCodeFileSync( file,isFileChange,changedLines,parseCodeFileSyncCallback ) {
    	console.log("we are in parseCodeFileSync")
    	try {
            var functionCount = 0;
            var textContent = "FunctionId \t\t calledFunctionId \n";
            var functionContent = "FunctionId \t\t FunctionName \n";
    	    var functionObjDict = { "functions" : [] };
            var reservedKeyWords = ['void', 'private', 'public', 'protected', 'static','internal'];
    	    var data = file.fileContent.toString();
    	    var classCount = 0;
            var classStart = false;
            var functionStart = false;
            var curlyCount = 0;
            var functionLineCount = 0;
            var variableCount = 0;
            var currentFunctionName = '';
            var classes = [];
            var lineCount = 0;
            var cost = 0;
            var functions = [];
            var classDict = [];
            var funcDict = [];
            var codeReviewBlocksDict = [];
            var CodeReviewBlocks = [];
            var CodeReviewBlocksCount = 0;
            var usingCount = 0;
            var namespaceCount = 0;
            var namespaceStart;
            var className = '';
            var namespace = [];
            var namespaceDict = [];
            var using = [];
            var usingDict = [];
            // var isLineChanged = false;
            var currentLine = "";
            var codeReviewBlocksObj = [];
            var ifElseStart = false;
            var ifElseCurrentLine = "";
            var ifElseCurlycount = 0;
            var codeReviewIfElseBlocksObj = [];
            var codeReviewIfElseBlocksDict = [];
            var blockLineCount = 0;
            var duplicateIfElseBlocksDict = [];
            var codeReviewFunBlocksObj = [];
            var codeReviewFunBlocksDict = [];
            var funCurrentLine = "";
            var tryCount = 0;
            var catchCount = 0;
            var functionStartIndex = 0;
            var functioEndIndex = 0;
            var isFunctionChagned = false;
            var isBlockChanged = false;
            var isIfElseBlockChanged = false;
            var isCurlyCountStarted = false;
            if (data.length > 0) {

                //console.log( 'received data: ' + data );
                var linesArr = data.toString().split('\n');
                async.each(linesArr, function(entry,eachCallback) {	            
                    try {
                        
                        lineCount += 1;
                        if (typeof entry != 'undefined') {
                            if (entry.charAt(0) != "/" && entry.length > 0) {
                                entry = entry.replace(/ +/g, ' ');   
                                var line = entry.toLowerCase();
                                var stripedLine = entry.trim();
                                var tokens = stripedLine.split(" ");

                                if ((line.indexOf("using ") > -1) && !functionStart) {
                                    usingCount += 1;
                                    var usingTemp = { 'namespaceName': tokens[1] };
                                    using.push(usingTemp);
                                    usingDict[file.filename] = using;
                                } 
                                else if ((line.indexOf("namespace ") > -1) && (line.indexOf(";") == -1)) {
                                    namespaceCount = namespaceCount + 1;
                                    namespace.push({ 'namespaceName': tokens[1] });
                                    namespaceDict[file.filename] = namespace;
                                    namespaceStart = true;
                                }
                                else if ((line.indexOf("class ") > -1) && (line.indexOf(";") == -1)) {
                                  
                                    var index = tokens.indexOf("class");
                                    className = tokens[index + 1];
                                    className = className.replace(/(\r\n|\n|\r)/gm, "");
                                    // currentClassName = className;
                                    classCount = classCount + 1;
                                    var baseclassArr = line.split(':');
                                    if (typeof baseclassArr[1] != 'undefined') {
                                        var baseclassname = baseclassArr[1];
                                        baseclassname = baseclassname.replace(/(\r\n|\n|\r)/gm, "");
                                    } else {
                                        var baseclassname = '';
                                    }

                                    classes.push({ "classname": className, "baseclassname" : baseclassname });
                                    classDict[file.filename] = classes;
                                    classStart = true;
                                    functions = [];
                                }
                                else if ((reservedKeyWords.indexOf(tokens[0].trim()) > -1) && (line.indexOf("(") > -1) && (line.indexOf(")") > -1) && (line.indexOf(";") == -1) && namespaceStart && classStart && !functionStart && (curlyCount == 0)) {
                             
                                    tokenCount = 0
                                    cost = 1;
                                    functionStart = true;
                                    variables = [];
                                    curlyCount = 0;
                                    functionLineCount = 0;
                                    isFunctionChagned = false;
                                    tryCount = 0;
                                    catchCount = 0;
                                    var lineArr = entry.split('(');
                                    var currentFunctionNameArr = lineArr[0].trim().split(" ");
                                    currentFunctionName = currentFunctionNameArr[currentFunctionNameArr.length - 1];
                                    if (currentFunctionName.indexOf("<") > -1) {
                                        currentFunctionName = currentFunctionName.split("<");
                                        currentFunctionName = currentFunctionName[0]
                                    }
                                    functionObjDict.functions[functionCount] = { "FunctionName": currentFunctionName, "FunctionId": functionCount };
                                    console.log("currentFunctionName" + currentFunctionName);
                                    
    					            functionContent += functionCount + "\t\t" + currentFunctionName + "\t\t"+file.fullpath+"\n";
                                    functionCount = functionCount + 1
                                    functionStartIndex = lineCount;
                                    if (line.indexOf("{") > -1) {
                                        curlyCount = curlyCount + 1;
                                    }
                                }
                                else if (functionStart) {
                                    if (line.indexOf("{") > -1) {
                                        curlyCount = curlyCount + 1;
                                    }
                                    
                                    if (line.indexOf("}") > -1) {
                                        curlyCount = curlyCount - 1;
                                    }
                                    if (line.indexOf("try") > -1) {
                                        tryCount = tryCount + 1;
                                    }
                                    if (line.indexOf("catch") > -1) {
                                        catchCount = catchCount + 1;
                                    }
                                    var trimLine = entry.trim();
                                    getVariables(tokens, currentFunctionName, variableCount, trimLine);
                                    
                                  
    					            if (curlyCount === 0 && functionStart) {
                                        // last block is not added add it now
                                        if (currentLine.length > 0) {                                            
                                            codeReviewBlocksObj.push({ "block" : currentLine, "islinechanged" : isBlockChanged , "Line": lineCount });
                                            codeReviewBlocksDict[file.filename] = codeReviewBlocksObj;
                                            currentLine = "";
                                            isBlockChanged = false;
                                        }
                                        functionStart = false;
                                        ifElseStart = false;
                                        functionObj = { "functionname": currentFunctionName, "functionLineCount": functionLineCount, "cost": cost, "variableCount": variableCount, "functioEndIndex": lineCount, "functionStartIndex": functionStartIndex, "catchCount": catchCount, "isFunctionChagned": isFunctionChagned };
                                        functions.push(functionObj);
                                        funcDict[className] = functions;
                                        variables = [];
                                        console.log("currentFunctionName IS " + currentFunctionName);
                                        
                                        codeReviewFunBlocksObj.push({ "block" : funCurrentLine, "islinechanged" : isFunctionChagned, "Line": functionStartIndex });
                                        //console.log("codeReviewFunBlocksObj=========>" +util.inspect(codeReviewFunBlocksObj));
                                        codeReviewFunBlocksDict[file.filename] = codeReviewFunBlocksObj;
                                        funCurrentLine = "";
                                        ifElseCurrentLine = "";
                                    }
                                    if (stripedLine.length > 0) {
                                        functionLineCount = functionLineCount + 1;
                                    }
                                    //make block 
                                    if ((line.indexOf("{") == -1) && (line.indexOf("}") == -1)) {
                                        if ((stripedLine.length == 0 && currentLine.length > 0)) {
                                            var CodeReviewBlocksCountArr = Object.keys(CodeReviewBlocks);
                                            if (CodeReviewBlocksCountArr.indexOf(CodeReviewBlocksCount) > -1) {
                                                currentLine = CodeReviewBlocks[CodeReviewBlocksCount];
                                                CodeReviewBlocks[CodeReviewBlocksCount] = currentLine;
                                                CodeReviewBlocksCount = CodeReviewBlocksCount + 1;
                                                currentLine = "";

                                            } else {
                                                //console.log(" you are in else "+lineCount);
                                                codeReviewBlocksObj.push({ "block" : currentLine, "islinechanged" : isBlockChanged , "Line": lineCount });
                                                codeReviewBlocksDict[file.filename] = codeReviewBlocksObj;
                                                currentLine = "";
                                                isBlockChanged = false;
                                            }
                                        } else {
                                            currentLine = currentLine + " " + stripedLine.replace(';', '');
                                            currentLine = currentLine.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    									            
                                        }
                                    }
                                    funCurrentLine = funCurrentLine + " " + stripedLine.replace(';', '');
                                    funCurrentLine = funCurrentLine.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
                                    
                                    if (( line.indexOf("if") > -1 && line.indexOf("(") > -1 && line.indexOf("(") > -1) || (line.indexOf("else") > -1)) {
                                        //console.log("If else started");
                                        ifElseStart = true;
    			                        //	blockLineCount = 0;                        	
    			                        	
                                    }
                                    
                                    if (ifElseStart) {
                                        //console.log("ifElseStart");
                                        
                                        if (line.indexOf("{") > -1) {
                                            ifElseCurlycount = ifElseCurlycount + 1;
                                            isCurlyCountStarted = true;
                                        }
                                        
                                        if (line.indexOf("}") > -1) {
                                            ifElseCurlycount = ifElseCurlycount - 1;
                                        }
                                        if ((ifElseCurlycount === 0 && ifElseStart && isCurlyCountStarted == true) || (line.indexOf("}") > -1 && line.indexOf("else") > -1 && line.indexOf("{") > -1)) {
                                            
                                            if (line.indexOf("else") > -1 && line.indexOf("{") > -1) {
                                                ifElseStart = true;
    					                			
                                            } else {
                                                ifElseStart = false;
                                            }
                                            //var isLineChanged = false;
                                            codeReviewIfElseBlocksObj.push({ "block" : ifElseCurrentLine, "islinechanged" : isIfElseBlockChanged, "Line" : lineCount });
                                            codeReviewIfElseBlocksDict[file.filename] = codeReviewIfElseBlocksObj;
                                            ifElseCurrentLine = "";
                                            isIfElseBlockChanged = false;
                                            isCurlyCountStarted = false;
                                        }
                                        ifElseCurrentLine = ifElseCurrentLine + " " + stripedLine.replace(';', '');
                                        ifElseCurrentLine = ifElseCurrentLine.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
                                    }
                                } else {
                                    var isGlobalVar = true;
                                    getGlobalVariables(tokens);
                                }
                            }
                        }
                    } catch (err) {
                        fs.appendFile(errorLogFilePath, err, function (err) {
                        });
                    }
                    eachCallback();
                },function(){
                    parseCodeFileSyncCallback(classDict, funcDict,codeReviewBlocksDict, codeReviewFunBlocksDict, codeReviewIfElseBlocksDict );
                });
            }		 	
    	}catch (err) {
    	 	fs.appendFile(errorLogFilePath, err+'in Parsing', function (err) {
    		});
    	}		
    }

    function stripParenthesis( str ) {
     	try{
    		var parenIndex = str.indexOf( "(" );
    	    var strippedName = str;
    	    if ( parenIndex > -1 ) {
    	        strippedName = str.substring( 0, parenIndex );
    	    }
    	    return strippedName;
        } catch (err) {
    	 	fs.appendFile(errorLogFilePath, err, function (err) {
    		});
    	}
    }

    //Parse variables
    function getVariables(tokens, functionName, variableCount, lineVariable) {
        try {
            var indexOfNew = tokens.indexOf("new");
            var variableType = '';
            var variableName = '';
            var expensiveResources = ['sqlconnection', 'sqladapter', 'Folders', 'sqlcommand', 'dataset'];
            
            if (indexOfNew > -1) {
                variableName = tokens[indexOfNew - 2];
                variableType = tokens[indexOfNew - 3];
                variableCount = variableCount + 1;
                //check cost
                if (typeof variableType != 'undefined') {
                    if (variableType.length > 0) {
                        if (expensiveResources.indexOf(variableType.toLowerCase()) != -1) {
                            cost = 100;
                        }
                    }
                }
            }
            var lineVar = ['curl_init', 'curl_exec'];
            var varTypes = ['string','String','int','Int64','boolean','Boolean'];
            if (lineVariable.search("=") > -1 && lineVariable.search(".") > -1 && lineVariable.search("new") == -1 && varTypes.indexOf(tokens[0]) == -1) {
                if (tokens.indexOf("=") == 2) {
                    variableName = tokens[1];
                    variableCount = variableCount + 1;
                    variableType = "External";
                }
            }
            
            if (tokens.indexOf("string") > -1) {
                var index = tokens.indexOf("string");
                variableName = tokens[index + 1];
                variableCount = variableCount + 1;
                variableType = "string";
            }
            if (tokens.indexOf("String") > -1) {
                var index = tokens.indexOf("String");
                variableName = tokens[index + 1];
                globalVariableCount = globalVariableCount + 1;
                variableType = "string";
            }
            if (tokens.indexOf("int") > -1) {
                var index = tokens.indexOf("Int");
                variableName = tokens[index + 1];
                variableCount = variableCount + 1;
                variableType = "int";
            }
            if (tokens.indexOf("Int64") > -1) {
                var index = tokens.indexOf("Int64");
                variableName = tokens[index + 1];
                globalVariableCount = globalVariableCount + 1;
                variableType = "Int64";
            }
            if (tokens.indexOf("var") > -1) {
                var index = tokens.indexOf("var");
                variableName = tokens[index + 1];
                variableCount = variableCount + 1;
                variableType = "var";
            }
            if (tokens.indexOf("boolean") > -1) {
                var index = tokens.indexOf("boolean");
                variableName = tokens[index + 1];
                variableCount = variableCount + 1;
                variableType = "boolean";
            }
            if (tokens.indexOf("Boolean") > -1) {
                
                var index = tokens.indexOf("Boolean");
                variableName = tokens[index + 1];
                globalVariableCount = globalVariableCount + 1;
                variableType = "boolean";
            }
            if (typeof variableName != 'undefined') {
                if (variableName.length > 0) {
                    var variableObj = { "variableName": variableName, "type": variableType };
                    variables.push(variableObj);
                    variableDict[functionName] = variables;
                }
            }
        } catch (err) {
            fs.appendFile(errorLogFilePath, err + 'in Variable', function (err) {
            });
        }
    }

    //Parse variables
    function getGlobalVariables(tokens) {
        var variableName = "";
        try {
            var indexOfNew = tokens.indexOf("new");
            var variableType = '';
            var variableName = '';
            var expensiveResources = ['sqlconnection', 'sqladapter', 'Folders', 'sqlcommand', 'dataset'];
            if (indexOfNew > -1) {
                variableName = tokens[indexOfNew - 2];
                variableType = tokens[indexOfNew - 3];
                globalVariableCount = globalVariableCount + 1;
                //check cost
                if (typeof variableType != 'undefined') {
                    if (variableType.length > 0) {
                        if (expensiveResources.indexOf(variableType.toLowerCase()) != -1) {
                            cost = 100;
                        }
                    }
                }
            }
            var lineVar = ['curl_init', 'curl_exec'];
            
            if (tokens.indexOf("string") > -1) {
                var index = tokens.indexOf("string");
                variableName = tokens[index + 1];
                globalVariableCount = globalVariableCount + 1;
                variableType = "string";
            }
            if (tokens.indexOf("String") > -1) {
                
                var index = tokens.indexOf("String");
                variableName = tokens[index + 1];
                globalVariableCount = globalVariableCount + 1;
                variableType = "string";
            }
            if (tokens.indexOf("int") > -1) {
                var index = tokens.indexOf("Int");
                variableName = tokens[index + 1];
                globalVariableCount = globalVariableCount + 1;
                variableType = "int";
            }
            if (tokens.indexOf("Int64") > -1) {
                var index = tokens.indexOf("Int64");
                variableName = tokens[index + 1];
                globalVariableCount = globalVariableCount + 1;
                variableType = "Int64";
            }
            if (tokens.indexOf("var") > -1) {
                var index = tokens.indexOf("var");
                variableName = tokens[index + 1];
                globalVariableCount = globalVariableCount + 1;
                variableType = "var";
            }
            if (tokens.indexOf("boolean") > -1) {
                var index = tokens.indexOf("boolean");
                variableName = tokens[index + 1];
                globalVariableCount = globalVariableCount + 1;
                variableType = "boolean";
            }
            
            if (tokens.indexOf("Boolean") > -1) {
                var index = tokens.indexOf("Boolean");
                variableName = tokens[index + 1];
                globalVariableCount = globalVariableCount + 1;
                variableType = "boolean";
            }
            if (typeof variableName != 'undefined' && variableName.length > 0 ) {
                var variableObj = { "variableName": variableName, "type": variableType };
                globalVariables.push(variableObj);
                globalVariableDict = globalVariables;
            }
    	    
        } catch (err) {
            fs.appendFile(errorLogFilePath, err + 'In Global Variable', function (err) {
            });
        }
    }


	exports.GenerateCSMap = GenerateCSMap;

	